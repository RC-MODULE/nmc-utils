Библиотека libEasyNMC, руководство программиста
-----------------------------------------------

Подробную информацию о функциях можно прочитать в формате doxygen. 
Ее можно скомпилировать набрав make doc в дереве nmc-utils
Информация об утилитах nmctl, nmrun и nmlogd представлена в формате man

Устройства
-----------
На каждое устройство NMC в /dev/ создается два устройства.
/dev/nmcXio  - устройства для работы с stdin/stdout
/dev/nmcXmem - устройство для работы с памятью nmc
где X=0,1,2,3


Общая информация
----------------
Библиотека предоставляет программисту инструменты для управления работой 
и организации обмена данными с DSP ядром NeuroMatrix. 
Для работы библиотеки необходим драйвер ядра EasyNMC. 
Хост система может отправить NeuroMatrix ядру 3 прерывания. 
* Немаскируемое NMI прерывания
* HP (High Priority)
* LP (Low Priority)

Ядро NeuroMatrix может отправлять хост-системе два прерывания: 
* HP (High Priority)
* LP (Low Priority)

NMI прерывание зарезервировано начальным кодом и используется для 
принудительной остановки работающего приложения. 

Ядро NMС имеет небольшое количество SRAM памяти, куда загружается начальный код, 
(занимающий ~ 2KiB в самом начале) Остальное место доступно для пользовательского 
приложения (приложений).

В К1879 для NMC отведены банки памяти IM0 и IM3, по 256KiB каждая. Так как 
они идут последовательно в адресном пространстве, то и определяются в виде 
единого сегмента в 512KiB доступного через /dev/nmc0mem В адресном пространстве 
NeuroMatrix эта память расположена начиная с нулевого 
адреса. 

ВАЖНО: NeuroMatrix не имеет байтовой адресации, и адресует ячейки по 32бита!


Сборка библиотеки
-----------------

TODO:

Подключение библиотеки
--------------------------
TODO: Подробное описание подключения

#include <easynmc.h>

-leasynmc

pkg-config easynmc


Открытие и закрытие ядра. 
-------------------------
struct easynmc_handle *easynmc_open(int coreid);
void easynmc_close(struct easynmc_handle *hndl);

Открытие ядра автоматически загружает начальный код, если этого уже не было сделано. 
Функции возвращают указатель на структуру, представляющую экземпляр открытого ядра. 
В случае ошибки easynmc_open вернет NULL

Вариант открытия ядра nmc
struct easynmc_handle *easynmc_open_noboot(int coreid);
идентичен по поведению вышепреведенному, за исключением того, что не пытается запустить 
на ядре начальный код. 

Начальный код берется по умолчанию из файла /lib/firmware/nmc/startup-(имя_ядра).abs
Либо из файла, путь к которому содержится в переменной окружения NMC_STARTUPCODE


struct easynmc_handle {
	int       id;        // ID открытого ядра 0,1,...
	int       iofd;      // Дескриптор stdio
	int       memfd;     // Дескриптор памяти
	char*     imem;      // Указатель (байтовая адресация) на память nmc, 
		  	     // При открытии ядра память mmap'ится в адресное пространство процесса
	uint32_t *imem32;    // Указатель (адресация 32х битными словами) на память nmc
		  	     // При открытии ядра память mmap'ится в адресное пространство процесса
	uint32_t  imem_size; // Размер собственной памяти nmc в байтах.
	struct easynmc_section_filter *sfilters;  //Связанный список секционных фильтров
};


Получение информации о ядре:
--------------------------------------

Функции записывают строки, содержащие имя и тип ядра, соотвественно
В предоставленный пользователем буфер.

/* FixMe: Buffer length? */ 
int easynmc_get_core_name(struct easynmc_handle *h, char* str);
int easynmc_get_core_type(struct easynmc_handle *h, char* str);

Имя ядра, это имя задаваемое в DeviceTree. Можно использовать для 
определения платформы, на которой запущено приложение. 
Для К1879 это "K1879-nmc"
Тип - версия архитектуры NeuroMatrix. Для К1879 - "nmc3"
Функции возвращают 0 если не произошло ошибок, в противном случае -1
и устанавливают errno соответсвующим образом.

Получение информации о состоянии ядра: 
enum easynmc_core_state easynmc_core_state(struct easynmc_handle *h);
const char* easynmc_state_name(enum easynmc_core_state state);

Первая из приведенных функций возвращает текущее состояние, которое может быть
одним из:  
enum easynmc_core_state {
	EASYNMC_CORE_COLD,    - Остановлено, начальный код не запушен
	EASYNMC_CORE_IDLE,    - Исполняется начальный код, и ожидает загрузки кода приложения.
	EASYNMC_CORE_RUNNING, - Исполняется код приложения 
	EASYNMC_CORE_PAUSED,  /* Зарезервировано */
	EASYNMC_CORE_INVALID  - Состояние ошибки (несовместимая версия начального кода и т.п.)
};

easynmc_state_name - возвращает указатель на строку содержащую текстовое представление 
состояния.  

Загрузка abs файлов
-------------------
int easynmc_load_abs(struct easynmc_handle *h, const char *path, uint32_t* ep, int flags);

Загрузка abs файла во внутреннюю память ядра. 
Возвращает 0 если все прошло без ошибок. 

После успешной загрузки точка входа записывается в по адресу *ep.
ep имеет валидное значение только в случае успешной загрузки abs файла. 
flags передает один или несколько флагов для загрузчика ABS файлов. 

Доступные флаги (можно указывать несколько через побитовое ИЛИ): 
ABSLOAD_FLAG_FORCE   - Принудительная загрузка (даже если ядро сейчас исполняет код). Опасно!
ABSLOAD_FLAG_STDIO   - Подключить stdio функции драйвера, если соответствующие секции есть в abs
ABSLOAD_FLAG_ARGS    - Передавать argc/argv, если соответствующие секции есть в abs
ABSLOAD_FLAG_SYNCLIB - Подключить библиотеку барьерной синхронизации.

#define ABSLOAD_FLAG_DEFAULT  \
	(ABSLOAD_FLAG_STDIO | ABSLOAD_FLAG_ARGS)

После успешной загрузки abs файла можно передать программе на nmc аргументы (argc, argv). 

Делается это вызовом: 
int easynmc_set_args(struct easynmc_handle *h, char* self, int argc, char **argv)

Если программа на nmc не поддерживает аргументы для main или загрузка abs файла проводилась
без флага ABSLOAD_FLAG_ARGS - функция вернет -1.
Если количество аргументов превышает зарезервированное место в секции для аргументов, будет 
возвращен -ENOMEM
Если аргументы переданы успешно - будет возвращен 0.

Пользовательские секционные фильтры
-----------------------------------

Библиотека позволяет подключать пользовательские секционные фильтры, которые срабатывают после загрузки
секции во внутреннюю память nmc. Таким образом, можно изменять содержимое определенных секций на этапе 
загрузки abs файла. 
Таким образом в этой бибилиотеке реализованы передача аргументов, stdio и т.п. 
easynmc-filters.c можно использовать как пример использования этого API.
Каждый пользовательский фильтр надо регистрировать ПЕРЕД загрузкой abs файла при помощи 
easynmc_register_section_filter(h, &stdio_filter);	   


Запуск и остановка приложения
-----------------------------

Для этого служат функции 
int easynmc_start_app(struct easynmc_handle *h, uint32_t entry);
int easynmc_stop_app(struct easynmc_handle *h);

Для запуска приложения необходимо передать корректную точку входа, полученную при загрузке abs файла
ВАЖНО: Поведение при запуске по неправильному entry point не определено! Так как у NeuroMatrix есть
доступ ко всему адресному пространству, это может привести к неработоспособности системы и потребовать
перезагрузки.

Для получения последнего exit code из main() существует функция:
 
int easynmc_exitcode(struct easynmc_handle *h);

Внимание! Вызов этой функции имеет смысл только тогда, когда ядро находится в состоянии 
EASYNMC_STATE_IDLE!

Ожидание событий
-----------------
На самом нижнем уровне библиотека представляет разработчику API для получения "сырых" событий. 
Событиями в этом контексте являются:
* Прерывание HP
* Прерывание LP
* Факт отправки ядру NMI прерывания (например, другим приложением)

Эти события можно получать двумя способами, описанными ниже

1. Блокирующее ожидание на токене.
----------------------------------

Этот API работает с токенами, которые накапливают произошедшие события. 
Для работы с токенами существуют следущие функции: 

Создание нового токена. После окончания работы для предотвращения утечки памяти 
токен надо передать функции free(), так как память для токена выделяется при помощи malloc()
struct easynmc_token *easynmc_token_new(struct easynmc_handle *h, uint32_t events);
events - битмаска событий, в получении которых пользователь заинтересован. 
Начиная с момента создания токена, пришедшие события регистрируются в нем. 
Очистка токена сбрасывает все накопленные события. 
int easynmc_token_clear(struct easynmc_token *t);

Ожидание на токене. Блокирует поток исполнения либо на timeout миллисекунд, либо
до появления следующего события. Возвращает по одному событию за вызов. 
В случае наличия нескольких событий, они выдаются НЕ ПО ПОРЯДКУ возникновения, а 
по приоритету: 
* Сначала все события NMI
* Потом все события HP (High Priority)
* Потом все события LP.

События TIMEOUT, ERROR и CANCEL не могут быть замаскированы и НЕ должны указываться в маске 
событий, передаваемых easynmc_token_new().
int easynmc_token_wait(struct easynmc_token *t, uint32_t timeout);

Отмена ожидания на токене может быть произведена:
* Отправкой сигнала процессу, ожидающему на токене.
* Вызовом int easynmc_token_cancel_wait(struct easynmc_token *t);

В обоих случаях token_wait() вернет событие EASYNMC_EVT_CANCELLED

easynmc_token_cancel_wait() можно вызывать из любого процесса в системе, 
токен МОЖНО помещать в разделяемую память. 
Известные проблемы: При вызове easynmc_token_cancel_wait() - Поток исполнения 
блокируется до окончания отмены. В случае если на токене сейчас
не выполняется ожидания, то отмена заблокирует поток исполнения до истечения 
таймаута. 

Количество используемых одновременно токенов не ограничено! Каждое новое 
событие будет доставлено во все ожидающие его токены. 


Пример ожидания событий на токене: 

int do_mon(int coreid, char* optarg)
{
	int ret = 1;
	printf("Monitoring events on core %d, CTRL+C to terminate\n", coreid);
	struct easynmc_handle *h = easynmc_open(coreid);
	if (!h) { 
		fprintf(stderr, "easynmc_open() failed\n");
		return 1;
	}
	int evt;
	struct easynmc_token *tok = easynmc_token_new(h, EASYNMC_EVT_ALL);
	while (1) { 
		evt = easynmc_token_wait(tok, 50000);
		if (evt != EASYNMC_EVT_TIMEOUT)
			printf("Event: %s\n", easynmc_evt_name(evt));
		
	}
	easynmc_close(h);
	return ret;	
}

2. epoll (рекомендуемый способ!)

Ограничения: Ожидается, что только один процесс в системе будет выполнять 
poll/epoll для получения событий от одного ядра nmc.
Опрос следует  выполнять на дескрипторе памяти nmc (struct easynmc_handle*)->memfd
Перед вызовом poll/epoll cледует сбросить счетчик poll событий вызовом 

int easynmc_pollmark(struct easynmc_handle *h);

При использовании POLL/EPOLL используется следующая схема: 

    POLLIN  == Получено LP прерывания
    POLLPRI == Получено HP прерывание
    POLLHUP == Было отправлено NMI прерывание ядру   

easynmc.h определяет следующие константы для опроса: 

EPOLLLP, EPOLLHP, EPOLLNMI
и, соответственно
POLLLP, POLLHP, POLLNMI

Пример использования epoll (из nmctl.c)

int do_mon_epoll(int coreid, char* optarg)
{
	int ret = 1;
	printf("Monitoring events on core %d (epoll), CTRL+C to terminate\n", coreid);
	struct easynmc_handle *h = easynmc_open(coreid);
	if (!h) { 
		fprintf(stderr, "easynmc_open() failed\n");
		return 1;
	}
	
	if (0!=easynmc_pollmark(h))
		goto errclose;

	struct epoll_event event;
	struct epoll_event *events;
	int efd = epoll_create(1);
	if (efd == -1)
	{
		perror ("epoll_create");
		ret = 1;
		goto errclose;
	}
	
	event.data.fd = h->memfd;
	event.events = EPOLLNMI | EPOLLHP | EPOLLLP;
	ret = epoll_ctl (efd, EPOLL_CTL_ADD, h->memfd, &event);
	if (ret == -1)
	{
		perror ("epoll_ctl");
		ret = 1;
		goto errclose;
	}
	
	 events = calloc (NUMEVENTS, sizeof event);
	 
	 while (1) { 
		 int n, i;
		 n = epoll_wait(efd, events, NUMEVENTS, -1);
		 for (i = 0; i < n; i++) {
			 if (events[i].events & EPOLLNMI)
				 printf("Event: NMI\n");
			 if (events[i].events & EPOLLLP)
				 printf("Event: LP\n");
			 if (events[i].events & EPOLLHP)
				 printf("Event: HP\n");
			 if (events[i].events & EPOLLERR)
				 printf("Event: ERROR\n");
		 }
	 }
errclose:
	easynmc_close(h);
	return ret;	
}


Смотрите также 
---------------

* doc/easynmc-stdio-guide.txt  - Руководство по использованию STDIO
* doc/easynmc-barrier-sync.txt - Руководство по использованию механизма барьерной синхронизации.
* doc/nm-pl-compat.txt         - Информация по PL_xxx API (не рекомендуется для новых приложений)


Известные ограничения и проблемы 
--------------------------------

* Отсутствует возможность запуска NMC-кода из DDR памяти. 
* Отсутствуют инструменты для работы с буферами в DDR памяти
* Отмена ожидания на токене, где не осуществляется ожидания приводит к блокировке 
  потока испольнения до истечения таймаута. 
* Только один процесс может использовать poll/epoll для работы с одним ядром nmc
* Это все еще бэта версия!


Приложения. 
Здесь записаны разные полезные трюки, которые не влезли 
в вышеописанную документацию

Приложение 1. Полезные трюки из командной строки
------------------------------------------------

Снятие дампа памяти NMC
# cat /dev/nmcXmem > dump.bin

Терминал для работы с stdin/stdout nmc:
# minicom -o -D /dev/nmc0io
или 
#screen /dev/nmc0io

Запуск init кода на всех ядрах nmc
# nmctl --boot

Запуск пользовательского init кода на незапущенном ядре nmc

# NMC_STARTUPCODE=myinitcode.abs nmctl --core=0 --boot

